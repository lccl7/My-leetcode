//a typical backtracking problem.
//row: stands for which row we have reach. tmp is 1D where the position the queen stand on.
//for example: when the row = 0, tmp = {1, 0, 2, 3}, the position
//we can try is [0,1], [0,0], [0,2], [0,3].
//is_solution tests the place that is valid. the if statement is used for
//taking away in the same column, and in the same diagonal.(the row is grow every time, 
//so we don't care for it.
//process_string is used at last when we can push_back the valid place.
//the valid place is that (row, tmp[row]), so we test that j == tmp[i]
class Solution {
public:
    vector<vector<string> > solveNQueens(int n) {
        vector<vector<string>> res;
        vector<int> tmp(n);
        dfs(n, 0, res, tmp);
        return res;
    }
 
    void process_string(int n, vector<vector<string>> &res, vector<int> tmp)
    {
        vector<string> vs;
        for(int i = 0; i < n; ++i)
        {
            string s;
            for(int j = 0; j < n; ++j)
            {
                if(j == tmp[i])
                    s += "Q";
                else
                    s += ".";
            }
            vs.push_back(s);
        }
        res.push_back(vs);
    }
    
    bool is_solution(int row, vector<int> tmp)
    {
        for(int i = 0; i < row; ++i)
        {
            if(tmp[i] == tmp[row] || abs(tmp[i]-tmp[row]) == row - i)
                return false;
        }
        return true;
    }
    
    void dfs(int n, int row, vector<vector<string>> &res, vector<int> tmp)
    {
        if(n == row)
        {
            process_string(n, res, tmp);
            return;
        }
        else
        {
            for(int i = 0; i < n; ++i)
            {
                tmp[row] = i;
                if(is_solution(row, tmp))
                {
                    dfs(n, row+1, res, tmp);
                }
            }
        }
    }
};
