//A greedy algorithm problem. we just tranverse the array to see
//if we can reach the end. First we initialize A[0] the maxlength.
//then if we can reach i and from i we can reach the end, we return true.
//On the contrary, if the maxlength less than i, and when we reach i ,
//A[i] is 0, we know that we never reach the end, we return false.
//In the last case, we update the maxlength once we can reach farther.
class Solution {
public:
    bool canJump(int A[], int n) {
        if(n <= 1) return true;
        if(A[0] >= n-1) return true;
        int maxlength = A[0];
        if(maxlength == 0) return false;
        for(int i = 1; i < n-1; ++i)
        {
            if(maxlength >= i && (i + A[i] >= n-1))
                return true;
            if(maxlength <= i && A[i] == 0)
                return false;
            if(maxlength < A[i] + i)
                maxlength = A[i] + i;
        }
        return false;
    }
};
